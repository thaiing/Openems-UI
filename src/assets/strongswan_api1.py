# FILE: strongswan_api.py

# -*- coding: utf-8 -*-
from flask import Flask, request, jsonify, abort
from flask_cors import CORS
import subprocess
import os
import re
import json
from werkzeug.utils import secure_filename

app = Flask(__name__)
CORS(app)

# Giữ nguyên cấu trúc thư mục cho IKEv2-Cert
SWANCTL_CONF_DIR = "/etc/swanctl/conf.d/"
# Thêm cấu trúc thư mục cho ipsec.conf (legacy)
IPSEC_D_DIR = "/etc/ipsec.d/"
IPSEC_SECRETS_PATH = "/etc/ipsec.secrets"

UPLOAD_FOLDER = '/tmp/certs'
os.makedirs(SWANCTL_CONF_DIR, exist_ok=True)
os.makedirs(IPSEC_D_DIR, exist_ok=True)
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

def run_command(command):
    try:
        result = subprocess.run(
            command, shell=True, check=True, capture_output=True, text=True
        )
        return {"success": True, "output": result.stdout.strip()}
    except subprocess.CalledProcessError as e:
        return {"success": False, "error": e.stderr.strip()}

def generate_s2s_ikev2_cert_conf(data):
    """
    HÀM NÀY ĐƯỢC GIỮ NGUYÊN 100% THEO FILE GỐC CỦA BẠN.
    """
    conn_name = data.get('name')
    if not conn_name: return ""
    metadata = {"category": data.get("category"), "auth_method": data.get("auth_method")}
    content = f"# METADATA: {json.dumps(metadata)}\n\n"
    content += f"connections {{\n  \"{conn_name}\" {{\n"
    ike_version = data.get('ike_version', 'any')
    if ike_version == 'ikev1': content += "    version = 1\n"
    elif ike_version == 'ikev2': content += "    version = 2\n"
    else: content += "    version = 0\n"
    if data.get('active_initiator'): content += "    auto = start\n"
    else: content += "    auto = add\n"
    if data.get('server_address'): content += f"    local_addrs = {data['server_address']}\n"
    if data.get('remote_address'): content += f"    remote_addrs = {data['remote_address']}\n"
    content += "    local {{\n      auth = pubkey\n"
    if data.get('server_certificate_name'): content += f"      certs = {data['server_certificate_name']}\n"
    if data.get('local_identity'): content += f"      id = \"{data['local_identity']}\"\n"
    content += "    }}\n"
    content += "    remote {{\n      auth = pubkey\n"
    if not data.get('auto_ca_select') and data.get('ca_certificate_name'):
        content += f"      cacerts = {data['ca_certificate_name']}\n"
    if not data.get('use_server_value') and data.get('peer_identity'):
        content += f"      id = \"{data['peer_identity']}\"\n"
    content += "    }}\n"
    content += "    children {{\n"
    content += f"      \"{conn_name}-child\" {{\n"
    content += f"        local_ts = {data.get('local_traffic_selector') or '0.0.0.0/0'}\n"
    content += f"        remote_ts = {data.get('remote_traffic_selector') or '0.0.0.0/0'}\n"
    content += f"        start_action = {data.get('start_action', 'none')}\n"
    content += "      }}\n    }}\n"
    content += "  }}\n}}\n"
    return content

def generate_ipsec_conf_psk(data):
    """
    Tạo nội dung file .conf cho PSK theo định dạng ipsec.conf (legacy).
    """
    conn_name = data.get('name')
    if not conn_name: return ""

    # Phase 1
    ike_proposal = f"{data.get('p1_encryption')}-{data.get('p1_authentication')}-modp{data.get('p1_dh_group')}"
    # Phase 2
    esp_proposal = f"{data.get('p1_encryption')}-{data.get('p1_authentication')}"

    content = f"# Connection '{conn_name}' generated by API\n"
    content += f"conn {conn_name}\n"
    content += f"    # -- Phase 1 --\n"
    content += f"    ike={ike_proposal}\n"
    content += f"    keyexchange=ikev{data.get('ike_version', '2')}\n"
    content += f"    ikelifetime={data.get('p1_key_lifetime', 86400)}s\n"
    content += f"    # -- Phase 2 --\n"
    content += f"    esp={esp_proposal}\n"
    content += f"    lifetime=3600s\n" # Mặc định lifetime cho phase 2
    content += f"    # -- Authentication --\n"
    content += f"    authby=secret\n"
    content += f"    leftid={data.get('p1_local_id')}\n"
    content += f"    # -- Network --\n"
    content += f"    left=%defaultroute\n"
    content += f"    leftsubnet={data.get('p2_local_address')}\n"
    content += f"    right={data.get('remote_gateway_ip')}\n"
    content += f"    rightsubnet={data.get('p2_remote_address')}\n"
    content += f"    # -- Action --\n"
    content += f"    auto=add\n"

    return content

def update_ipsec_secrets(data):
    """Cập nhật file /etc/ipsec.secrets."""
    local_id = data.get('p1_local_id')
    # Remote ID có thể là IP hoặc một định danh, ở đây dùng IP cho đơn giản
    remote_id = data.get('remote_gateway_ip')
    psk = data.get('pre_shared_key')

    if not (local_id and remote_id and psk):
        return # Không làm gì nếu thiếu thông tin

    new_line = f'{local_id} {remote_id} : PSK "{psk}"\n'

    lines = []
    try:
        if os.path.exists(IPSEC_SECRETS_PATH):
            with open(IPSEC_SECRETS_PATH, 'r') as f:
                lines = f.readlines()

        # Lọc ra các dòng không chứa local_id và remote_id
        filtered_lines = [line for line in lines if not (local_id in line and remote_id in line)]

        # Thêm dòng mới vào
        filtered_lines.append(new_line)

        with open(IPSEC_SECRETS_PATH, 'w') as f:
            f.writelines(filtered_lines)
        return True
    except IOError as e:
        print(f"Error updating ipsec.secrets: {e}")
        return False

# API save_connection được cập nhật
@app.route('/api/connections', methods=['POST'])
def save_connection():
    data = request.get_json()
    if not isinstance(data, dict) or not data.get('name'):
        abort(400, "Invalid JSON data or missing 'name' field.")

    conn_name = data['name']
    auth_method = data.get('auth_method')

    if auth_method == 'ikev2-psk':
        # Xử lý theo định dạng ipsec.conf
        conf_content = generate_ipsec_conf_psk(data)
        conf_file_path = os.path.join(IPSEC_D_DIR, f"{conn_name}.conf")

        try:
            with open(conf_file_path, 'w') as f:
                f.write(conf_content)
        except IOError as e:
            return jsonify({"error": "Failed to write ipsec config file", "details": str(e)}), 500

        if not update_ipsec_secrets(data):
            return jsonify({"error": "Failed to write ipsec.secrets file"}), 500

        # Lệnh reload cho ipsec.conf
        reload_cmd = "ipsec reload"

    elif auth_method == 'ikev2-cert':
        # Xử lý theo định dạng swanctl (giữ nguyên logic gốc)
        conf_content = generate_s2s_ikev2_cert_conf(data)
        conf_file_path = os.path.join(SWANCTL_CONF_DIR, f"{conn_name}.conf")
        try:
            with open(conf_file_path, 'w') as f:
                f.write(conf_content)
        except IOError as e:
            return jsonify({"error": "Failed to write swanctl config file", "details": str(e)}), 500

        # Lệnh reload cho swanctl
        reload_cmd = "swanctl --load-all"
    else:
        abort(400, f"Unsupported auth_method: {auth_method}")

    if data.get('andUpdate', False):
        load_result = run_command(reload_cmd)
        if not load_result["success"]:
            return jsonify({"error": "Config saved, but failed to reload", "details": load_result["error"]}), 500

    return jsonify({"message": f"Connection '{conn_name}' saved successfully!"}), 201

# Các API còn lại giữ nguyên hoặc điều chỉnh nhỏ
# ...

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
